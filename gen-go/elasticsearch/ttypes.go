// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package elasticsearch

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var GoUnusedProtection__ int

type Method int64

const (
	Method_GET     Method = 0
	Method_PUT     Method = 1
	Method_POST    Method = 2
	Method_DELETE  Method = 3
	Method_HEAD    Method = 4
	Method_OPTIONS Method = 5
)

func (p Method) String() string {
	switch p {
	case Method_GET:
		return "Method_GET"
	case Method_PUT:
		return "Method_PUT"
	case Method_POST:
		return "Method_POST"
	case Method_DELETE:
		return "Method_DELETE"
	case Method_HEAD:
		return "Method_HEAD"
	case Method_OPTIONS:
		return "Method_OPTIONS"
	}
	return "<UNSET>"
}

func MethodFromString(s string) (Method, error) {
	switch s {
	case "Method_GET":
		return Method_GET, nil
	case "Method_PUT":
		return Method_PUT, nil
	case "Method_POST":
		return Method_POST, nil
	case "Method_DELETE":
		return Method_DELETE, nil
	case "Method_HEAD":
		return Method_HEAD, nil
	case "Method_OPTIONS":
		return Method_OPTIONS, nil
	}
	return Method(0), fmt.Errorf("not a valid Method string")
}

func MethodPtr(v Method) *Method { return &v }

type Status int64

const (
	Status_CONT                          Status = 100
	Status_SWITCHING_PROTOCOLS           Status = 101
	Status_OK                            Status = 200
	Status_CREATED                       Status = 201
	Status_ACCEPTED                      Status = 202
	Status_NON_AUTHORITATIVE_INFORMATION Status = 203
	Status_NO_CONTENT                    Status = 204
	Status_RESET_CONTENT                 Status = 205
	Status_PARTIAL_CONTENT               Status = 206
	Status_MULTI_STATUS                  Status = 207
	Status_MULTIPLE_CHOICES              Status = 300
	Status_MOVED_PERMANENTLY             Status = 301
	Status_FOUND                         Status = 302
	Status_SEE_OTHER                     Status = 303
	Status_NOT_MODIFIED                  Status = 304
	Status_USE_PROXY                     Status = 305
	Status_TEMPORARY_REDIRECT            Status = 307
	Status_BAD_REQUEST                   Status = 400
	Status_UNAUTHORIZED                  Status = 401
	Status_PAYMENT_REQUIRED              Status = 402
	Status_FORBIDDEN                     Status = 403
	Status_NOT_FOUND                     Status = 404
	Status_METHOD_NOT_ALLOWED            Status = 405
	Status_NOT_ACCEPTABLE                Status = 406
	Status_PROXY_AUTHENTICATION          Status = 407
	Status_REQUEST_TIMEOUT               Status = 408
	Status_CONFLICT                      Status = 409
	Status_GONE                          Status = 410
	Status_LENGTH_REQUIRED               Status = 411
	Status_PRECONDITION_FAILED           Status = 412
	Status_REQUEST_ENTITY_TOO_LARGE      Status = 413
	Status_REQUEST_URI_TOO_LONG          Status = 414
	Status_UNSUPPORTED_MEDIA_TYPE        Status = 415
	Status_REQUESTED_RANGE_NOT_SATISFIED Status = 416
	Status_EXPECTATION_FAILED            Status = 417
	Status_UNPROCESSABLE_ENTITY          Status = 422
	Status_LOCKED                        Status = 423
	Status_FAILED_DEPENDENCY             Status = 424
	Status_INTERNAL_SERVER_ERROR         Status = 500
	Status_NOT_IMPLEMENTED               Status = 501
	Status_BAD_GATEWAY                   Status = 502
	Status_SERVICE_UNAVAILABLE           Status = 503
	Status_GATEWAY_TIMEOUT               Status = 504
	Status_INSUFFICIENT_STORAGE          Status = 506
)

func (p Status) String() string {
	switch p {
	case Status_CONT:
		return "Status_CONT"
	case Status_SWITCHING_PROTOCOLS:
		return "Status_SWITCHING_PROTOCOLS"
	case Status_OK:
		return "Status_OK"
	case Status_CREATED:
		return "Status_CREATED"
	case Status_ACCEPTED:
		return "Status_ACCEPTED"
	case Status_NON_AUTHORITATIVE_INFORMATION:
		return "Status_NON_AUTHORITATIVE_INFORMATION"
	case Status_NO_CONTENT:
		return "Status_NO_CONTENT"
	case Status_RESET_CONTENT:
		return "Status_RESET_CONTENT"
	case Status_PARTIAL_CONTENT:
		return "Status_PARTIAL_CONTENT"
	case Status_MULTI_STATUS:
		return "Status_MULTI_STATUS"
	case Status_MULTIPLE_CHOICES:
		return "Status_MULTIPLE_CHOICES"
	case Status_MOVED_PERMANENTLY:
		return "Status_MOVED_PERMANENTLY"
	case Status_FOUND:
		return "Status_FOUND"
	case Status_SEE_OTHER:
		return "Status_SEE_OTHER"
	case Status_NOT_MODIFIED:
		return "Status_NOT_MODIFIED"
	case Status_USE_PROXY:
		return "Status_USE_PROXY"
	case Status_TEMPORARY_REDIRECT:
		return "Status_TEMPORARY_REDIRECT"
	case Status_BAD_REQUEST:
		return "Status_BAD_REQUEST"
	case Status_UNAUTHORIZED:
		return "Status_UNAUTHORIZED"
	case Status_PAYMENT_REQUIRED:
		return "Status_PAYMENT_REQUIRED"
	case Status_FORBIDDEN:
		return "Status_FORBIDDEN"
	case Status_NOT_FOUND:
		return "Status_NOT_FOUND"
	case Status_METHOD_NOT_ALLOWED:
		return "Status_METHOD_NOT_ALLOWED"
	case Status_NOT_ACCEPTABLE:
		return "Status_NOT_ACCEPTABLE"
	case Status_PROXY_AUTHENTICATION:
		return "Status_PROXY_AUTHENTICATION"
	case Status_REQUEST_TIMEOUT:
		return "Status_REQUEST_TIMEOUT"
	case Status_CONFLICT:
		return "Status_CONFLICT"
	case Status_GONE:
		return "Status_GONE"
	case Status_LENGTH_REQUIRED:
		return "Status_LENGTH_REQUIRED"
	case Status_PRECONDITION_FAILED:
		return "Status_PRECONDITION_FAILED"
	case Status_REQUEST_ENTITY_TOO_LARGE:
		return "Status_REQUEST_ENTITY_TOO_LARGE"
	case Status_REQUEST_URI_TOO_LONG:
		return "Status_REQUEST_URI_TOO_LONG"
	case Status_UNSUPPORTED_MEDIA_TYPE:
		return "Status_UNSUPPORTED_MEDIA_TYPE"
	case Status_REQUESTED_RANGE_NOT_SATISFIED:
		return "Status_REQUESTED_RANGE_NOT_SATISFIED"
	case Status_EXPECTATION_FAILED:
		return "Status_EXPECTATION_FAILED"
	case Status_UNPROCESSABLE_ENTITY:
		return "Status_UNPROCESSABLE_ENTITY"
	case Status_LOCKED:
		return "Status_LOCKED"
	case Status_FAILED_DEPENDENCY:
		return "Status_FAILED_DEPENDENCY"
	case Status_INTERNAL_SERVER_ERROR:
		return "Status_INTERNAL_SERVER_ERROR"
	case Status_NOT_IMPLEMENTED:
		return "Status_NOT_IMPLEMENTED"
	case Status_BAD_GATEWAY:
		return "Status_BAD_GATEWAY"
	case Status_SERVICE_UNAVAILABLE:
		return "Status_SERVICE_UNAVAILABLE"
	case Status_GATEWAY_TIMEOUT:
		return "Status_GATEWAY_TIMEOUT"
	case Status_INSUFFICIENT_STORAGE:
		return "Status_INSUFFICIENT_STORAGE"
	}
	return "<UNSET>"
}

func StatusFromString(s string) (Status, error) {
	switch s {
	case "Status_CONT":
		return Status_CONT, nil
	case "Status_SWITCHING_PROTOCOLS":
		return Status_SWITCHING_PROTOCOLS, nil
	case "Status_OK":
		return Status_OK, nil
	case "Status_CREATED":
		return Status_CREATED, nil
	case "Status_ACCEPTED":
		return Status_ACCEPTED, nil
	case "Status_NON_AUTHORITATIVE_INFORMATION":
		return Status_NON_AUTHORITATIVE_INFORMATION, nil
	case "Status_NO_CONTENT":
		return Status_NO_CONTENT, nil
	case "Status_RESET_CONTENT":
		return Status_RESET_CONTENT, nil
	case "Status_PARTIAL_CONTENT":
		return Status_PARTIAL_CONTENT, nil
	case "Status_MULTI_STATUS":
		return Status_MULTI_STATUS, nil
	case "Status_MULTIPLE_CHOICES":
		return Status_MULTIPLE_CHOICES, nil
	case "Status_MOVED_PERMANENTLY":
		return Status_MOVED_PERMANENTLY, nil
	case "Status_FOUND":
		return Status_FOUND, nil
	case "Status_SEE_OTHER":
		return Status_SEE_OTHER, nil
	case "Status_NOT_MODIFIED":
		return Status_NOT_MODIFIED, nil
	case "Status_USE_PROXY":
		return Status_USE_PROXY, nil
	case "Status_TEMPORARY_REDIRECT":
		return Status_TEMPORARY_REDIRECT, nil
	case "Status_BAD_REQUEST":
		return Status_BAD_REQUEST, nil
	case "Status_UNAUTHORIZED":
		return Status_UNAUTHORIZED, nil
	case "Status_PAYMENT_REQUIRED":
		return Status_PAYMENT_REQUIRED, nil
	case "Status_FORBIDDEN":
		return Status_FORBIDDEN, nil
	case "Status_NOT_FOUND":
		return Status_NOT_FOUND, nil
	case "Status_METHOD_NOT_ALLOWED":
		return Status_METHOD_NOT_ALLOWED, nil
	case "Status_NOT_ACCEPTABLE":
		return Status_NOT_ACCEPTABLE, nil
	case "Status_PROXY_AUTHENTICATION":
		return Status_PROXY_AUTHENTICATION, nil
	case "Status_REQUEST_TIMEOUT":
		return Status_REQUEST_TIMEOUT, nil
	case "Status_CONFLICT":
		return Status_CONFLICT, nil
	case "Status_GONE":
		return Status_GONE, nil
	case "Status_LENGTH_REQUIRED":
		return Status_LENGTH_REQUIRED, nil
	case "Status_PRECONDITION_FAILED":
		return Status_PRECONDITION_FAILED, nil
	case "Status_REQUEST_ENTITY_TOO_LARGE":
		return Status_REQUEST_ENTITY_TOO_LARGE, nil
	case "Status_REQUEST_URI_TOO_LONG":
		return Status_REQUEST_URI_TOO_LONG, nil
	case "Status_UNSUPPORTED_MEDIA_TYPE":
		return Status_UNSUPPORTED_MEDIA_TYPE, nil
	case "Status_REQUESTED_RANGE_NOT_SATISFIED":
		return Status_REQUESTED_RANGE_NOT_SATISFIED, nil
	case "Status_EXPECTATION_FAILED":
		return Status_EXPECTATION_FAILED, nil
	case "Status_UNPROCESSABLE_ENTITY":
		return Status_UNPROCESSABLE_ENTITY, nil
	case "Status_LOCKED":
		return Status_LOCKED, nil
	case "Status_FAILED_DEPENDENCY":
		return Status_FAILED_DEPENDENCY, nil
	case "Status_INTERNAL_SERVER_ERROR":
		return Status_INTERNAL_SERVER_ERROR, nil
	case "Status_NOT_IMPLEMENTED":
		return Status_NOT_IMPLEMENTED, nil
	case "Status_BAD_GATEWAY":
		return Status_BAD_GATEWAY, nil
	case "Status_SERVICE_UNAVAILABLE":
		return Status_SERVICE_UNAVAILABLE, nil
	case "Status_GATEWAY_TIMEOUT":
		return Status_GATEWAY_TIMEOUT, nil
	case "Status_INSUFFICIENT_STORAGE":
		return Status_INSUFFICIENT_STORAGE, nil
	}
	return Status(0), fmt.Errorf("not a valid Status string")
}

func StatusPtr(v Status) *Status { return &v }

type RestRequest struct {
	Method     Method            `thrift:"method,1,required" json:"method"`
	Uri        string            `thrift:"uri,2,required" json:"uri"`
	Parameters map[string]string `thrift:"parameters,3" json:"parameters"`
	Headers    map[string]string `thrift:"headers,4" json:"headers"`
	Body       []byte            `thrift:"body,5" json:"body"`
}

func NewRestRequest() *RestRequest {
	return &RestRequest{}
}

func (p *RestRequest) GetMethod() Method {
	return p.Method
}

func (p *RestRequest) GetUri() string {
	return p.Uri
}

var RestRequest_Parameters_DEFAULT map[string]string

func (p *RestRequest) GetParameters() map[string]string {
	return p.Parameters
}

var RestRequest_Headers_DEFAULT map[string]string

func (p *RestRequest) GetHeaders() map[string]string {
	return p.Headers
}

var RestRequest_Body_DEFAULT []byte

func (p *RestRequest) GetBody() []byte {
	return p.Body
}
func (p *RestRequest) IsSetParameters() bool {
	return p.Parameters != nil
}

func (p *RestRequest) IsSetHeaders() bool {
	return p.Headers != nil
}

func (p *RestRequest) IsSetBody() bool {
	return p.Body != nil
}

func (p *RestRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RestRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Method(v)
		p.Method = temp
	}
	return nil
}

func (p *RestRequest) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Uri = v
	}
	return nil
}

func (p *RestRequest) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Parameters = tMap
	for i := 0; i < size; i++ {
		var _key0 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key0 = v
		}
		var _val1 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val1 = v
		}
		p.Parameters[_key0] = _val1
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *RestRequest) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Headers = tMap
	for i := 0; i < size; i++ {
		var _key2 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key2 = v
		}
		var _val3 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val3 = v
		}
		p.Headers[_key2] = _val3
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *RestRequest) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Body = v
	}
	return nil
}

func (p *RestRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("RestRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RestRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("method", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:method: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Method)); err != nil {
		return fmt.Errorf("%T.method (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:method: %s", p, err)
	}
	return err
}

func (p *RestRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("uri", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:uri: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Uri)); err != nil {
		return fmt.Errorf("%T.uri (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:uri: %s", p, err)
	}
	return err
}

func (p *RestRequest) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetParameters() {
		if err := oprot.WriteFieldBegin("parameters", thrift.MAP, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:parameters: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Parameters)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Parameters {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:parameters: %s", p, err)
		}
	}
	return err
}

func (p *RestRequest) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetHeaders() {
		if err := oprot.WriteFieldBegin("headers", thrift.MAP, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:headers: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Headers)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Headers {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:headers: %s", p, err)
		}
	}
	return err
}

func (p *RestRequest) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetBody() {
		if err := oprot.WriteFieldBegin("body", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:body: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Body); err != nil {
			return fmt.Errorf("%T.body (5) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:body: %s", p, err)
		}
	}
	return err
}

func (p *RestRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RestRequest(%+v)", *p)
}

type RestResponse struct {
	Status  Status            `thrift:"status,1,required" json:"status"`
	Headers map[string]string `thrift:"headers,2" json:"headers"`
	Body    []byte            `thrift:"body,3" json:"body"`
}

func NewRestResponse() *RestResponse {
	return &RestResponse{}
}

func (p *RestResponse) GetStatus() Status {
	return p.Status
}

var RestResponse_Headers_DEFAULT map[string]string

func (p *RestResponse) GetHeaders() map[string]string {
	return p.Headers
}

var RestResponse_Body_DEFAULT []byte

func (p *RestResponse) GetBody() []byte {
	return p.Body
}
func (p *RestResponse) IsSetHeaders() bool {
	return p.Headers != nil
}

func (p *RestResponse) IsSetBody() bool {
	return p.Body != nil
}

func (p *RestResponse) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RestResponse) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Status(v)
		p.Status = temp
	}
	return nil
}

func (p *RestResponse) ReadField2(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Headers = tMap
	for i := 0; i < size; i++ {
		var _key4 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key4 = v
		}
		var _val5 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val5 = v
		}
		p.Headers[_key4] = _val5
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *RestResponse) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Body = v
	}
	return nil
}

func (p *RestResponse) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("RestResponse"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *RestResponse) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("status", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:status: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Status)); err != nil {
		return fmt.Errorf("%T.status (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:status: %s", p, err)
	}
	return err
}

func (p *RestResponse) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetHeaders() {
		if err := oprot.WriteFieldBegin("headers", thrift.MAP, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:headers: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Headers)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Headers {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:headers: %s", p, err)
		}
	}
	return err
}

func (p *RestResponse) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetBody() {
		if err := oprot.WriteFieldBegin("body", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:body: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Body); err != nil {
			return fmt.Errorf("%T.body (3) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:body: %s", p, err)
		}
	}
	return err
}

func (p *RestResponse) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RestResponse(%+v)", *p)
}
